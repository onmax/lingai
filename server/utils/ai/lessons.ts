/**
 * Generate Spanish learning sentences with audio using AI
 */
import type { Lesson, Sentence } from '../../../shared/types/lesson'
import { Buffer } from 'node:buffer'
import process from 'node:process'
import { openai } from '@ai-sdk/openai'
import { valibotSchema } from '@ai-sdk/valibot'
import { generateObject } from 'ai'
import { and, eq } from 'drizzle-orm'
import OpenAI from 'openai'
import { array, string, object as valibotObject } from 'valibot'
import { type CourseLesson, fetchCourseContent } from '../../data/course-content'

export interface GenerateLessonsArgs {
  topics: string[]
  userId: string
  lessonNumber?: number
}

export interface GeneratedLessonResult {
  lesson: Lesson
  sentences: Sentence[]
}

interface ParsedSentence {
  targetText: string
  userText: string
  context: string
}

export async function generateLessons({
  topics,
  userId,
  lessonNumber,
}: GenerateLessonsArgs): Promise<GeneratedLessonResult> {
  try {
    // Get the course content for this lesson
    const courseContent = await fetchCourseContent()
    const courseLesson = courseContent.find(lesson => lesson.lesson_number === lessonNumber)
    if (!courseLesson) {
      throw new Error(`No course content found for lesson ${lessonNumber}`)
    }

    // Combine topics with course content
    const allTopics = [
      ...topics,
      ...courseLesson.vocabulary_topics,
      ...courseLesson.grammar_points,
      ...courseLesson.communication_goals,
    ]

    // Generate 5 Spanish sentences using AI
    const topicsString = allTopics.join(', ')
    const parsedSentences = await generateSpanishSentences(topicsString, courseLesson)

    if (!parsedSentences || parsedSentences.length === 0) {
      throw new Error('No valid sentences generated by AI')
    }

    // Save lesson to database
    const db = useDrizzle()

    // Create lesson
    const lessonTitle = courseLesson.title

    const [newLesson] = await db.insert(tables.lessons).values({
      userId,
      title: lessonTitle,
      targetLanguage: 'spanish',
      userLanguage: 'english',
      difficulty: 'intermediate',
      topics: JSON.stringify(allTopics),
      lessonNumber: courseLesson.lesson_number,
      totalSentences: parsedSentences.length,
    }).returning()

    if (!newLesson) {
      throw new Error('Failed to create lesson')
    }

    // Save sentences to database
    const sentencePromises = parsedSentences.map(async (sentenceData: ParsedSentence, index: number) => {
      const [sentence] = await db.insert(tables.sentences).values({
        lessonId: newLesson.id,
        userId,
        targetText: sentenceData.targetText,
        userText: sentenceData.userText,
        sentenceOrder: index + 1,
        context: sentenceData.context,
        difficulty: 'intermediate',
        audioGenerated: false,
      }).returning()

      return sentence
    })

    const sentences = await Promise.all(sentencePromises)

    // Generate audio for sentences (sync - wait for completion)
    await generateAudioForSentences(sentences)

    // Fetch updated sentences with audio URLs after generation
    const updatedSentences = await db.select()
      .from(tables.sentences)
      .where(eq(tables.sentences.lessonId, newLesson.id))
      .orderBy(tables.sentences.sentenceOrder)
      .all()

    // Parse lesson data for return
    const lessonData: Lesson = {
      ...newLesson,
      topics: JSON.parse(newLesson.topics || '[]'),
      createdAt: new Date(newLesson.createdAt),
      updatedAt: new Date(newLesson.updatedAt),
    }

    const sentenceData: Sentence[] = updatedSentences.map((sentence: any) => ({
      ...sentence,
      audioUrl: sentence.audioUrl || undefined,
      context: sentence.context || undefined,
      difficulty: sentence.difficulty || undefined,
      tags: sentence.tags ? JSON.parse(sentence.tags) : undefined,
      createdAt: new Date(sentence.createdAt),
      updatedAt: new Date(sentence.updatedAt),
    }))

    return {
      lesson: lessonData,
      sentences: sentenceData,
    }
  }
  catch (error) {
    consola.error('Error generating lessons:', error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to generate lessons: ${error instanceof Error ? error.message : String(error)}`,
    })
  }
}

/**
 * Generate Spanish sentences using OpenAI
 */
async function generateSpanishSentences(topicsString: string, courseLesson: CourseLesson): Promise<ParsedSentence[]> {
  const sentenceSchema = valibotObject({
    targetText: string('Simple sentence in Spanish'),
    userText: string('Translation in English'),
    context: string('Brief usage context for the sentence'),
  })

  const sentencesSchema = valibotObject({
    sentences: array(sentenceSchema, 'Exactly 5 simple Spanish sentences for language learning'),
  })

  // Generate structured object using AI SDK
  const { object } = await generateObject({
    model: openai('gpt-4o-mini'),
    schema: valibotSchema(sentencesSchema),
    schemaName: 'spanish_sentences',
    schemaDescription: 'Spanish learning sentences with English translations and context',
    system: `You are a Spanish language learning content generator. Generate exactly 5 simple Spanish sentences for language learning.

REQUIREMENTS:
- Use vocabulary related to the provided topics
- Focus on the following grammar points: ${courseLesson.grammar_points.join(', ')}
- Help achieve these communication goals: ${courseLesson.communication_goals.join(', ')}
- Also make sure to include the vocabulary topics: ${courseLesson.vocabulary_topics.join(', ')}
- Target difficulty level: ${courseLesson.difficulty_level} (CEFR level)
- Difficulty score: ${courseLesson.difficulty_score}/10 (1=easiest, 10=most difficult)
- Appropriate for ${courseLesson.difficulty_level} level Spanish learners  
- Practical and realistic for everyday conversations
- Short and easy to understand (no more than 10-12 words each)
- Each sentence should be unique and cover different aspects of the topics
- The sentences must be a conversation between two people and the order of the sentences must be a conversation
- It should be structured in a way that the previous sentence is a continuation of the previous sentence`,
    prompt: `Generate 5 simple Spanish sentences about: ${topicsString}. Target difficulty: ${courseLesson.difficulty_level} level (score ${courseLesson.difficulty_score}/10). Each sentence should be appropriate for this difficulty level and include a natural English translation with usage context.`,
    maxTokens: 2048,
    temperature: 0.3,
    maxRetries: 2,
  })

  consola.success(`Successfully generated ${object.sentences.length} Spanish sentences`)
  return object.sentences
}

/**
 * Retry wrapper for blob storage operations with exponential backoff
 */
async function retryBlobOperation<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000,
): Promise<T> {
  let lastError: Error = new Error('Operation failed after all retries')

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation()
    }
    catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error))

      // Check if this is a retryable Cloudflare error
      const isRetryableError = error && typeof error === 'object'
        && 'message' in error
        && (
          (error.message as string).includes('10043') // Service unavailable
          || (error.message as string).includes('10000') // Generic server error
          || (error.message as string).includes('timeout')
          || (error.message as string).includes('network')
        )

      if (!isRetryableError || attempt === maxRetries) {
        throw lastError
      }

      // Exponential backoff with jitter
      const delay = baseDelay * 2 ** (attempt - 1) + Math.random() * 1000
      consola.warn(`Blob operation failed (attempt ${attempt}/${maxRetries}), retrying in ${Math.round(delay)}ms: ${lastError.message}`)
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }

  throw lastError
}

/**
 * Generate audio for Spanish sentences using OpenAI TTS
 */
async function generateAudioForSentences(sentences: any[]): Promise<void> {
  consola.warn(`Starting audio generation for ${sentences.length} Spanish sentences`)

  const db = useDrizzle()
  const config = useRuntimeConfig()

  if (!config.openaiApiKey) {
    consola.error('OpenAI API key not configured')
    throw new Error('OpenAI API key is required for audio generation')
  }

  // Initialize OpenAI client
  const openaiClient = new OpenAI({
    apiKey: config.openaiApiKey,
  })

  for (const sentence of sentences) {
    try {
      consola.warn(`Generating Spanish audio for sentence ${sentence.id}: "${sentence.targetText}"`)

      // Generate audio using OpenAI TTS with Spanish voice
      const mp3 = await openaiClient.audio.speech.create({
        model: 'gpt-4o-mini-tts',
        voice: 'nova', // Good Spanish voice
        input: sentence.targetText,
        response_format: 'mp3',
        speed: 1.0,
        instructions: 'Speak in a cheerful and positive tone in spanish',
      })

      consola.info(`✅ OpenAI TTS generation completed for sentence ${sentence.id}`)

      // Get the audio buffer
      const audioBuffer = Buffer.from(await mp3.arrayBuffer())
      const audioKey = `audio/users/${sentence.userId}/sentences/${sentence.id}.mp3`

      // Store the audio in blob storage with retry logic
      try {
        await retryBlobOperation(async () => {
          // Convert Buffer to Blob for NuxtHub compatibility
          const audioBlob = new Blob([audioBuffer], { type: 'audio/mpeg' })
          await hubBlob().put(audioKey, audioBlob, {
            httpMetadata: {
              contentType: 'audio/mpeg',
            },
          })
          consola.success(`✅ Audio stored successfully: ${audioKey}`)
        }, 3, 2000) // 3 retries with 2s base delay
      }
      catch (blobError) {
        const errorMessage = blobError instanceof Error ? blobError.message : String(blobError)

        // Check if this is a known Cloudflare service issue
        const isCloudflareServiceIssue = errorMessage.includes('10043')
          || errorMessage.includes('cloudflarestatus.com')
          || errorMessage.includes('contact customer support')

        if (isCloudflareServiceIssue) {
          consola.error(`❌ Cloudflare service issue detected for ${audioKey}. Marking sentence for later retry.`)

          // Mark sentence as needing audio retry rather than failing completely
          try {
            await db.update(tables.sentences)
              .set({
                audioGenerated: false,
                audioUrl: null,
                updatedAt: sql`(unixepoch())`,
              })
              .where(eq(tables.sentences.id, sentence.id))

            consola.warn(`⚠️ Sentence ${sentence.id} marked for audio retry due to service issue`)
            continue // Continue with next sentence instead of failing
          }
          catch (dbError) {
            consola.error(`Failed to update sentence ${sentence.id} after service issue:`, dbError)
          }
        }
        else {
          consola.error(`❌ Blob storage failed for ${audioKey}:`, blobError)
          throw blobError
        }
      }

      // Update the sentence record with audio URL
      await db.update(tables.sentences)
        .set({
          audioUrl: `/api/audio/${audioKey}`,
          audioGenerated: true,
          updatedAt: sql`(unixepoch())`,
        })
        .where(eq(tables.sentences.id, sentence.id))

      consola.success(`✅ Spanish audio generated for sentence ${sentence.id}`)

      // Small delay to respect rate limits
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    catch (error) {
      const isDevEnvironment = process.env.NODE_ENV === 'development'
      const isBlobError = error && typeof error === 'object' && 'message' in error
        && (error.message as string).includes('ArrayBufferView')

      if (isDevEnvironment && isBlobError) {
        consola.warn(`⚠️ Audio generation skipped in development for sentence ${sentence.id} (blob storage issue)`)
        // In development, just mark as completed without audio for UI testing
        try {
          await db.update(tables.sentences)
            .set({
              audioGenerated: true, // Mark as generated to avoid retry loops
              audioUrl: null, // No URL since blob storage failed
              updatedAt: sql`(unixepoch())`,
            })
            .where(eq(tables.sentences.id, sentence.id))
        }
        catch (dbError) {
          consola.error(`Failed to update sentence ${sentence.id} after dev audio skip:`, dbError)
        }
      }
      else {
        consola.error(`❌ Failed to generate audio for sentence ${sentence.id}:`, error)
        // Mark as failed but continue
        try {
          await db.update(tables.sentences)
            .set({
              audioGenerated: false,
              updatedAt: sql`(unixepoch())`,
            })
            .where(eq(tables.sentences.id, sentence.id))
        }
        catch (dbError) {
          consola.error(`Failed to update sentence ${sentence.id} after audio error:`, dbError)
        }
      }
    }
  }

  consola.success(`Completed Spanish audio generation for ${sentences.length} sentences`)
}

/**
 * Retry audio generation for sentences that failed due to service issues
 */
export async function retryFailedAudioGeneration(lessonId?: string | number): Promise<void> {
  const db = useDrizzle()

  // Find sentences without audio
  let failedSentences

  if (lessonId) {
    const lessonIdNum = typeof lessonId === 'string' ? Number.parseInt(lessonId, 10) : lessonId
    failedSentences = await db.select()
      .from(tables.sentences)
      .where(
        and(
          eq(tables.sentences.audioGenerated, false),
          eq(tables.sentences.lessonId, lessonIdNum),
        ),
      )
      .all()
  }
  else {
    failedSentences = await db.select()
      .from(tables.sentences)
      .where(eq(tables.sentences.audioGenerated, false))
      .all()
  }

  if (failedSentences.length === 0) {
    consola.info('No sentences found that need audio generation retry')
    return
  }

  consola.info(`Found ${failedSentences.length} sentences that need audio generation retry`)

  // Use the existing audio generation logic
  await generateAudioForSentences(failedSentences)
}
