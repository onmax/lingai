/**
 * 1. Generate 5 sentences for the lessons using AI with JSON schema
 * 2. Each sentence includes target language and user language
 * 3. Generate the audios and store them in blob storage
 */

import type { Lesson, Sentence } from '../../../shared/types/lesson'
import { desc, eq } from 'drizzle-orm'
import { array, object, parse, string } from 'valibot'

// Schema for AI response
const SentenceSchema = object({
  targetText: string('Target sentence'),
  userText: string('User language translation'),
  context: string('Context or usage notes'),
})

const SentencesResponseSchema = object({
  sentences: array(SentenceSchema, 'Array of 5 sentences'),
})

export interface GenerateLessonsArgs {
  topics: string[]
  targetLanguage: string
  userLanguage: string
  userId: string
}

export interface GeneratedLessonResult {
  lesson: Lesson
  sentences: Sentence[]
}

interface ParsedSentence {
  targetText: string
  userText: string
  context: string
}

export async function generateLessons({
  topics,
  targetLanguage,
  userLanguage,
  userId,
}: GenerateLessonsArgs): Promise<GeneratedLessonResult> {
  try {
    // Step 1: Generate 5 sentences using AI following NuxtHub guide
    const ai = hubAI()
    const topicsString = topics.join(', ')

    const systemPrompt = `Generate 5 ${targetLanguage} learning sentences for language learners.

Create sentences that:
- Use vocabulary related to the provided topics
- Are appropriate for intermediate ${targetLanguage} learners  
- Are practical and realistic for real-world conversations
- Can be easily understood and practiced
- Each sentence should be unique and cover different aspects of the topics

Return exactly 5 sentences in JSON format with this structure:
{
  "sentences": [
    {
      "targetText": "sentence in ${targetLanguage}",
      "userText": "translation in ${userLanguage}", 
      "context": "brief context or usage note"
    }
  ]
}`

    // Use hubAI() with messages format as shown in NuxtHub docs
    const response = await ai.run('@cf/meta/llama-3.1-8b-instruct', {
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: `Generate 5 ${targetLanguage} sentences about: ${topicsString}` },
      ],
    })

    // Parse the response from AI
    let aiOutput = (response as any)?.output?.generated_text || (response as any)?.response || response

    if (typeof aiOutput !== 'string') {
      if (aiOutput && typeof aiOutput === 'object') {
        aiOutput = aiOutput.text || aiOutput.content || aiOutput.message || JSON.stringify(aiOutput)
      }
      else {
        aiOutput = String(aiOutput)
      }
    }

    // Parse and validate the response
    let parsedSentences: ParsedSentence[]
    try {
      const jsonData = JSON.parse(aiOutput)
      const validatedData = parse(SentencesResponseSchema, jsonData)
      parsedSentences = validatedData.sentences
    }
    catch (parseError) {
      console.error('Failed to parse AI response as JSON:', parseError)
      console.error('Raw AI output:', aiOutput)

      // Fallback: try to extract sentences from text
      parsedSentences = extractSentencesFromText(aiOutput, targetLanguage)
    }

    if (!parsedSentences || parsedSentences.length === 0) {
      throw new Error('No valid sentences generated by AI')
    }

    // Step 2: Save lesson to database
    const db = useDrizzle()

    // Get next lesson number for this user
    const lastLesson = await db.select({ lessonNumber: tables.lessons.lessonNumber })
      .from(tables.lessons)
      .where(eq(tables.lessons.userId, userId))
      .orderBy(desc(tables.lessons.lessonNumber))
      .limit(1)
      .get()

    const nextLessonNumber = (lastLesson?.lessonNumber || 0) + 1

    // Create lesson
    const lessonTitle = `${targetLanguage} Lesson ${nextLessonNumber}: ${topics[0]}`

    const [newLesson] = await db.insert(tables.lessons).values({
      userId,
      title: lessonTitle,
      description: `Comprehensive ${targetLanguage} lesson covering: ${topics.join(', ')}`,
      targetLanguage: targetLanguage.toLowerCase(),
      userLanguage: userLanguage.toLowerCase(),
      difficulty: 'intermediate',
      topics: JSON.stringify(topics),
      lessonNumber: nextLessonNumber,
      totalSentences: parsedSentences.length,
    }).returning()

    if (!newLesson) {
      throw new Error('Failed to create lesson')
    }

    // Step 3: Save sentences to database
    const sentencePromises = parsedSentences.map(async (sentenceData: ParsedSentence, index: number) => {
      const [sentence] = await db.insert(tables.sentences).values({
        lessonId: newLesson.id,
        userId,
        targetText: sentenceData.targetText,
        userText: sentenceData.userText,
        sentenceOrder: index + 1,
        context: sentenceData.context,
        difficulty: 'intermediate',
        audioGenerated: false,
      }).returning()

      return sentence
    })

    const sentences = await Promise.all(sentencePromises)

    // Step 4: Generate audio for sentences (async - don't wait)
    generateAudioForSentences(sentences, targetLanguage).catch((error) => {
      console.error('Failed to generate audio for sentences:', error)
    })

    // Parse lesson data for return
    const lessonData: Lesson = {
      ...newLesson,
      description: newLesson.description || undefined,
      topics: JSON.parse(newLesson.topics || '[]'),
      createdAt: new Date(newLesson.createdAt),
      updatedAt: new Date(newLesson.updatedAt),
    }

    const sentenceData: Sentence[] = sentences.map((sentence: any) => ({
      ...sentence,
      audioUrl: sentence.audioUrl || undefined,
      context: sentence.context || undefined,
      difficulty: sentence.difficulty || undefined,
      tags: sentence.tags ? JSON.parse(sentence.tags) : undefined,
      createdAt: new Date(sentence.createdAt),
      updatedAt: new Date(sentence.updatedAt),
    }))

    return {
      lesson: lessonData,
      sentences: sentenceData,
    }
  }
  catch (error) {
    console.error('Error generating lessons:', error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to generate lessons: ${error instanceof Error ? error.message : String(error)}`,
    })
  }
}

/**
 * Fallback: Extract sentences from plain text when JSON parsing fails
 */
function extractSentencesFromText(content: string, targetLanguage: string): ParsedSentence[] {
  const sentences: ParsedSentence[] = []

  // Use simple line-by-line parsing to avoid regex complexity
  const lines = content.split('\n')

  lines.forEach((line) => {
    // Look for lines with translation separators
    if (line.includes(' - ') || line.includes(' — ') || line.includes(' – ')) {
      const separators = [' — ', ' – ', ' - ']
      for (const separator of separators) {
        if (line.includes(separator)) {
          const parts = line.split(separator)
          if (parts.length === 2 && parts[0] && parts[1]) {
            const sentence1 = parts[0].trim().replace(/^[*-]\s*/, '')
            const sentence2 = parts[1].trim()

            if (sentence1 && sentence2) {
              // Determine which is target language and which is translation
              const isSpanish1 = containsSpanishCharacters(sentence1)

              let targetText, userText
              if (targetLanguage.toLowerCase() === 'spanish' || targetLanguage.toLowerCase() === 'es') {
                targetText = isSpanish1 ? sentence1 : sentence2
                userText = isSpanish1 ? sentence2 : sentence1
              }
              else {
                targetText = sentence1
                userText = sentence2
              }

              sentences.push({
                targetText,
                userText,
                context: 'Generated from fallback parsing',
              })
            }
          }
          break
        }
      }
    }
  })

  // Ensure we have at least 5 sentences, pad with empty ones if needed
  while (sentences.length < 5) {
    sentences.push({
      targetText: `Ejemplo ${sentences.length + 1}`,
      userText: `Example ${sentences.length + 1}`,
      context: 'Placeholder sentence',
    })
  }

  return sentences.slice(0, 5) // Ensure exactly 5 sentences
}

/**
 * Check if text contains Spanish characters or common Spanish words
 */
function containsSpanishCharacters(text: string): boolean {
  const spanishPattern = /[ñáéíóúü¿¡]/i
  const spanishWords = /\b(?:el|la|los|las|un|una|de|en|con|por|para|que|es|son|está|están|hola|gracias|por favor)\b/i
  return spanishPattern.test(text) || spanishWords.test(text)
}

/**
 * Generate audio for sentences using Cloudflare AI
 * This runs asynchronously and updates the database when complete
 */
async function generateAudioForSentences(
  sentences: any[],
  targetLanguage: string,
): Promise<void> {
  console.warn(`Starting audio generation for ${sentences.length} sentences in ${targetLanguage}`)

  for (const sentence of sentences) {
    try {
      // TODO: Implement TTS using Cloudflare AI when text-to-speech models are available
      // This would involve:
      // 1. Using hubAI() to call a TTS model with sentence.targetText
      // 2. Storing audio blob in hubBlob() with a unique key
      // 3. Updating the sentence record with audioUrl and audioGenerated = true

      // For now, just log the attempt
      console.warn(`Would generate audio for: "${sentence.targetText}"`)

      // Simulate async work
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    catch (error) {
      console.error(`Failed to generate audio for sentence ${sentence.id}:`, error)
    }
  }
}
