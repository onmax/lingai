/**
 * Generate Spanish learning sentences with audio using AI
 */
import type { Lesson, Sentence } from '../../../shared/types/lesson'
import { Buffer } from 'node:buffer'
import process from 'node:process'
import { openai } from '@ai-sdk/openai'
import { valibotSchema } from '@ai-sdk/valibot'
import { generateObject } from 'ai'
import { desc, eq } from 'drizzle-orm'
import OpenAI from 'openai'
import { array, string, object as valibotObject } from 'valibot'

export interface GenerateLessonsArgs {
  topics: string[]
  userId: string
}

export interface GeneratedLessonResult {
  lesson: Lesson
  sentences: Sentence[]
}

interface ParsedSentence {
  targetText: string
  userText: string
  context: string
}

export async function generateLessons({
  topics,
  userId,
}: GenerateLessonsArgs): Promise<GeneratedLessonResult> {
  try {
    // Generate 5 Spanish sentences using AI
    const topicsString = topics.join(', ')
    const parsedSentences = await generateSpanishSentences(topicsString)

    if (!parsedSentences || parsedSentences.length === 0) {
      throw new Error('No valid sentences generated by AI')
    }

    // Save lesson to database
    const db = useDrizzle()

    // Get next lesson number for this user
    const lastLesson = await db.select({ lessonNumber: tables.lessons.lessonNumber })
      .from(tables.lessons)
      .where(eq(tables.lessons.userId, userId))
      .orderBy(desc(tables.lessons.lessonNumber))
      .limit(1)
      .get()

    const nextLessonNumber = (lastLesson?.lessonNumber || 0) + 1

    // Create lesson
    const firstTopic = topics[0] || 'General'
    const capitalizedTopic = firstTopic.charAt(0).toUpperCase() + firstTopic.slice(1)
    const lessonTitle = `${capitalizedTopic} - Lesson ${nextLessonNumber}`

    const [newLesson] = await db.insert(tables.lessons).values({
      userId,
      title: lessonTitle,
      targetLanguage: 'spanish',
      userLanguage: 'english',
      difficulty: 'intermediate',
      topics: JSON.stringify(topics),
      lessonNumber: nextLessonNumber,
      totalSentences: parsedSentences.length,
    }).returning()

    if (!newLesson) {
      throw new Error('Failed to create lesson')
    }

    // Save sentences to database
    const sentencePromises = parsedSentences.map(async (sentenceData: ParsedSentence, index: number) => {
      const [sentence] = await db.insert(tables.sentences).values({
        lessonId: newLesson.id,
        userId,
        targetText: sentenceData.targetText,
        userText: sentenceData.userText,
        sentenceOrder: index + 1,
        context: sentenceData.context,
        difficulty: 'intermediate',
        audioGenerated: false,
      }).returning()

      return sentence
    })

    const sentences = await Promise.all(sentencePromises)

    // Generate audio for sentences (async - don't wait)
    generateAudioForSentences(sentences).catch((error) => {
      consola.error('Failed to generate audio for sentences:', error)
    })

    // Parse lesson data for return
    const lessonData: Lesson = {
      ...newLesson,
      topics: JSON.parse(newLesson.topics || '[]'),
      createdAt: new Date(newLesson.createdAt),
      updatedAt: new Date(newLesson.updatedAt),
    }

    const sentenceData: Sentence[] = sentences.map((sentence: any) => ({
      ...sentence,
      audioUrl: sentence.audioUrl || undefined,
      context: sentence.context || undefined,
      difficulty: sentence.difficulty || undefined,
      tags: sentence.tags ? JSON.parse(sentence.tags) : undefined,
      createdAt: new Date(sentence.createdAt),
      updatedAt: new Date(sentence.updatedAt),
    }))

    return {
      lesson: lessonData,
      sentences: sentenceData,
    }
  }
  catch (error) {
    consola.error('Error generating lessons:', error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to generate lessons: ${error instanceof Error ? error.message : String(error)}`,
    })
  }
}

/**
 * Generate Spanish sentences using OpenAI
 */
async function generateSpanishSentences(topicsString: string): Promise<ParsedSentence[]> {
  const sentenceSchema = valibotObject({
    targetText: string('Simple sentence in Spanish'),
    userText: string('Translation in English'),
    context: string('Brief usage context for the sentence'),
  })

  const sentencesSchema = valibotObject({
    sentences: array(sentenceSchema, 'Exactly 5 simple Spanish sentences for language learning'),
  })

  // Generate structured object using AI SDK
  const { object } = await generateObject({
    model: openai('gpt-4o-mini'),
    schema: valibotSchema(sentencesSchema),
    schemaName: 'spanish_sentences',
    schemaDescription: 'Spanish learning sentences with English translations and context',
    system: `You are a Spanish language learning content generator. Generate exactly 5 simple Spanish sentences for language learning.

REQUIREMENTS:
- Use vocabulary related to the provided topics
- Appropriate for beginner to intermediate Spanish learners  
- Practical and realistic for everyday conversations
- Short and easy to understand (no more than 10-12 words each)
- Each sentence should be unique and cover different aspects of the topics`,
    prompt: `Generate 5 simple Spanish sentences about: ${topicsString}. Each sentence should be beginner-friendly and include a natural English translation with usage context.`,
    maxTokens: 2048,
    temperature: 0.3,
    maxRetries: 2,
  })

  consola.success(`Successfully generated ${object.sentences.length} Spanish sentences`)
  return object.sentences
}

/**
 * Generate audio for Spanish sentences using OpenAI TTS
 */
async function generateAudioForSentences(sentences: any[]): Promise<void> {
  consola.warn(`Starting audio generation for ${sentences.length} Spanish sentences`)

  const db = useDrizzle()
  const config = useRuntimeConfig()

  if (!config.openaiApiKey) {
    consola.error('OpenAI API key not configured')
    throw new Error('OpenAI API key is required for audio generation')
  }

  // Initialize OpenAI client
  const openaiClient = new OpenAI({
    apiKey: config.openaiApiKey,
  })

  for (const sentence of sentences) {
    try {
      consola.warn(`Generating Spanish audio for sentence ${sentence.id}: "${sentence.targetText}"`)

      // Generate audio using OpenAI TTS with Spanish voice
      const mp3 = await openaiClient.audio.speech.create({
        model: 'tts-1-hd',
        voice: 'nova', // Good Spanish voice
        input: sentence.targetText,
        response_format: 'mp3',
        speed: 1.0,
      })

      // Get the audio buffer
      const audioBuffer = Buffer.from(await mp3.arrayBuffer())
      const audioKey = `audio/sentences/${sentence.id}.mp3`

      // Store the audio in blob storage
      try {
        // Convert Buffer to Blob for NuxtHub compatibility
        const audioBlob = new Blob([audioBuffer], { type: 'audio/mpeg' })
        await hubBlob().put(audioKey, audioBlob, {
          httpMetadata: {
            contentType: 'audio/mpeg',
          },
        })
        consola.success(`✅ Audio stored successfully: ${audioKey}`)
      }
      catch (blobError) {
        consola.error(`❌ Blob storage failed for ${audioKey}:`, blobError)
        throw blobError
      }

      // Update the sentence record with audio URL
      await db.update(tables.sentences)
        .set({
          audioUrl: `/api/audio/${audioKey}`,
          audioGenerated: true,
          updatedAt: sql`(unixepoch())`,
        })
        .where(eq(tables.sentences.id, sentence.id))

      consola.success(`✅ Spanish audio generated for sentence ${sentence.id}`)

      // Small delay to respect rate limits
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    catch (error) {
      const isDevEnvironment = process.env.NODE_ENV === 'development'
      const isBlobError = error && typeof error === 'object' && 'message' in error
        && (error.message as string).includes('ArrayBufferView')

      if (isDevEnvironment && isBlobError) {
        consola.warn(`⚠️ Audio generation skipped in development for sentence ${sentence.id} (blob storage issue)`)
        // In development, just mark as completed without audio for UI testing
        try {
          await db.update(tables.sentences)
            .set({
              audioGenerated: true, // Mark as generated to avoid retry loops
              audioUrl: null, // No URL since blob storage failed
              updatedAt: sql`(unixepoch())`,
            })
            .where(eq(tables.sentences.id, sentence.id))
        }
        catch (dbError) {
          consola.error(`Failed to update sentence ${sentence.id} after dev audio skip:`, dbError)
        }
      }
      else {
        consola.error(`❌ Failed to generate audio for sentence ${sentence.id}:`, error)
        // Mark as failed but continue
        try {
          await db.update(tables.sentences)
            .set({
              audioGenerated: false,
              updatedAt: sql`(unixepoch())`,
            })
            .where(eq(tables.sentences.id, sentence.id))
        }
        catch (dbError) {
          consola.error(`Failed to update sentence ${sentence.id} after audio error:`, dbError)
        }
      }
    }
  }

  consola.success(`Completed Spanish audio generation for ${sentences.length} sentences`)
}
