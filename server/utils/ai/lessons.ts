/**
 * Generate simple sentences for language learning using Vercel AI SDK
 *
 * This module uses Vercel AI SDK's generateObject with OpenAI for structured data generation.
 * This approach eliminates JSON parsing errors and provides reliable, type-safe responses.
 *
 * Benefits:
 * - Guaranteed valid JSON structure via generateObject()
 * - Built-in retry mechanisms and error handling
 * - Zod schema validation for type safety
 * - No manual JSON parsing or cleanup required
 *
 * Setup:
 * - Requires OPENAI_API_KEY environment variable
 * - Uses gpt-4o-mini for cost-effective structured generation
 *
 * Each sentence includes target language, user language, context, and audio generation
 */

import type { Lesson, Sentence } from '../../../shared/types/lesson'
import { Buffer } from 'node:buffer'
import { openai } from '@ai-sdk/openai'
import { valibotSchema } from '@ai-sdk/valibot'
import { generateObject } from 'ai'
import { desc, eq } from 'drizzle-orm'
import { array, string, object as valibotObject } from 'valibot'
import { SYSTEM_PROMPTS, USER_PROMPTS } from './prompts'

export interface GenerateLessonsArgs {
  topics: string[]
  targetLanguage: string
  userLanguage: string
  userId: string
}

export interface GeneratedLessonResult {
  lesson: Lesson
  sentences: Sentence[]
}

interface ParsedSentence {
  targetText: string
  userText: string
  context: string
}

export async function generateLessons({
  topics,
  targetLanguage,
  userLanguage,
  userId,
}: GenerateLessonsArgs): Promise<GeneratedLessonResult> {
  try {
    // Step 1: Generate 5 simple sentences using AI with structured output
    const topicsString = topics.join(', ')

    const systemPrompt = SYSTEM_PROMPTS.generateSentences(targetLanguage)

    // Generate sentences using OpenAI via Vercel AI SDK
    const parsedSentences = await generateWithOpenAI(topicsString, targetLanguage, userLanguage, systemPrompt)

    if (!parsedSentences || parsedSentences.length === 0) {
      throw new Error('No valid sentences generated by AI')
    }

    // Step 2: Save lesson to database
    const db = useDrizzle()

    // Get next lesson number for this user
    const lastLesson = await db.select({ lessonNumber: tables.lessons.lessonNumber })
      .from(tables.lessons)
      .where(eq(tables.lessons.userId, userId))
      .orderBy(desc(tables.lessons.lessonNumber))
      .limit(1)
      .get()

    const nextLessonNumber = (lastLesson?.lessonNumber || 0) + 1

    // Create lesson
    const firstTopic = topics[0] || 'General'
    const capitalizedTopic = firstTopic.charAt(0).toUpperCase() + firstTopic.slice(1)
    const lessonTitle = `${capitalizedTopic} - Lesson ${nextLessonNumber}`

    const [newLesson] = await db.insert(tables.lessons).values({
      userId,
      title: lessonTitle,
      targetLanguage: targetLanguage.toLowerCase(),
      userLanguage: userLanguage.toLowerCase(),
      difficulty: 'intermediate',
      topics: JSON.stringify(topics),
      lessonNumber: nextLessonNumber,
      totalSentences: parsedSentences.length,
    }).returning()

    if (!newLesson) {
      throw new Error('Failed to create lesson')
    }

    // Step 3: Save sentences to database
    const sentencePromises = parsedSentences.map(async (sentenceData: ParsedSentence, index: number) => {
      const [sentence] = await db.insert(tables.sentences).values({
        lessonId: newLesson.id,
        userId,
        targetText: sentenceData.targetText,
        userText: sentenceData.userText,
        sentenceOrder: index + 1,
        context: sentenceData.context,
        difficulty: 'intermediate',
        audioGenerated: false,
      }).returning()

      return sentence
    })

    const sentences = await Promise.all(sentencePromises)

    // Step 4: Generate audio for sentences (async - don't wait)
    generateAudioForSentences(sentences, targetLanguage).catch((error) => {
      consola.error('Failed to generate audio for sentences:', error)
    })

    // Parse lesson data for return
    const lessonData: Lesson = {
      ...newLesson,
      topics: JSON.parse(newLesson.topics || '[]'),
      createdAt: new Date(newLesson.createdAt),
      updatedAt: new Date(newLesson.updatedAt),
    }

    const sentenceData: Sentence[] = sentences.map((sentence: any) => ({
      ...sentence,
      audioUrl: sentence.audioUrl || undefined,
      context: sentence.context || undefined,
      difficulty: sentence.difficulty || undefined,
      tags: sentence.tags ? JSON.parse(sentence.tags) : undefined,
      createdAt: new Date(sentence.createdAt),
      updatedAt: new Date(sentence.updatedAt),
    }))

    return {
      lesson: lessonData,
      sentences: sentenceData,
    }
  }
  catch (error) {
    consola.error('Error generating lessons:', error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to generate lessons: ${error instanceof Error ? error.message : String(error)}`,
    })
  }
}

/**
 * Generate structured sentences using Vercel AI SDK with OpenAI and Valibot
 */
async function generateWithOpenAI(
  topicsString: string,
  targetLanguage: string,
  userLanguage: string,
  systemPrompt: string,
): Promise<ParsedSentence[]> {
  // Define the Valibot schema for sentence generation
  const sentenceSchema = valibotObject({
    targetText: string(`Simple sentence in ${targetLanguage}`),
    userText: string(`Translation in ${userLanguage}`),
    context: string('Brief usage context for the sentence'),
  })

  const sentencesSchema = valibotObject({
    sentences: array(sentenceSchema, 'Exactly 5 simple sentences for language learning'),
  })

  // Generate structured object using AI SDK with OpenAI and Valibot
  const { object } = await generateObject({
    model: openai('gpt-4o-mini'), // Cost-effective model for structured generation
    schema: valibotSchema(sentencesSchema), // Convert Valibot schema to AI SDK format
    schemaName: 'language_sentences',
    schemaDescription: 'Language learning sentences with translations and context',
    system: systemPrompt,
    prompt: USER_PROMPTS.generateSentences(topicsString, targetLanguage, userLanguage),
    maxTokens: 2048,
    temperature: 0.3,
    maxRetries: 2,
  })

  consola.success(`Successfully generated ${object.sentences.length} sentences using OpenAI generateObject with Valibot`)
  return object.sentences
}

/**
 * Generate audio for sentences using Cloudflare AI
 * This runs asynchronously and updates the database when complete
 */
async function generateAudioForSentences(
  sentences: any[],
  targetLanguage: string,
): Promise<void> {
  consola.warn(`Starting audio generation for ${sentences.length} sentences in ${targetLanguage}`)

  const db = useDrizzle()

  for (const sentence of sentences) {
    try {
      // Use MeloTTS model for text-to-speech generation
      const ai = hubAI()

      // Map language codes (Spanish -> 'es', English -> 'en', etc.)
      const langCode = targetLanguage.toLowerCase() === 'spanish'
        ? 'es'
        : targetLanguage.toLowerCase() === 'english'
          ? 'en'
          : targetLanguage.toLowerCase().substring(0, 2)

      consola.warn(`Generating audio for sentence ${sentence.id}: "${sentence.targetText}"`)

      const audioResponse = await ai.run('@cf/myshell-ai/melotts', {
        prompt: sentence.targetText,
        lang: langCode,
      })

      // The response contains base64-encoded MP3 audio
      let audioBase64: string
      if (typeof audioResponse === 'object' && audioResponse !== null && 'audio' in audioResponse) {
        audioBase64 = (audioResponse as any).audio
      }
      else if (typeof audioResponse === 'string') {
        audioBase64 = audioResponse
      }
      else {
        throw new TypeError('Unexpected audio response format')
      }

      // Store the audio in blob storage using hubBlob()
      const audioBuffer = Buffer.from(audioBase64, 'base64')
      const audioKey = `audio/sentences/${sentence.id}.mp3`

      await hubBlob().put(audioKey, audioBuffer, {
        httpMetadata: {
          contentType: 'audio/mpeg',
        },
      })

      // Update the sentence record with audio URL and mark as generated
      await db.update(tables.sentences)
        .set({
          audioUrl: `/api/audio/${audioKey}`,
          audioGenerated: true,
          updatedAt: sql`(unixepoch())`,
        })
        .where(eq(tables.sentences.id, sentence.id))

      consola.warn(`✅ Audio generated successfully for sentence ${sentence.id}`)

      // Add a small delay to avoid overwhelming the AI service
      await new Promise(resolve => setTimeout(resolve, 500))
    }
    catch (error) {
      consola.error(`❌ Failed to generate audio for sentence ${sentence.id}:`, error)

      // Mark as failed but don't throw - continue with other sentences
      try {
        await db.update(tables.sentences)
          .set({
            audioGenerated: false,
            updatedAt: sql`(unixepoch())`,
          })
          .where(eq(tables.sentences.id, sentence.id))
      }
      catch (dbError) {
        consola.error(`Failed to update sentence ${sentence.id} after audio generation error:`, dbError)
      }
    }
  }

  consola.warn(`Completed audio generation for ${sentences.length} sentences`)
}
