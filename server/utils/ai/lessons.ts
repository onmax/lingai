/**
 * Generate simple sentences for language learning using Vercel AI SDK
 *
 * This module uses Vercel AI SDK's generateObject with OpenAI for structured data generation.
 * This approach eliminates JSON parsing errors and provides reliable, type-safe responses.
 *
 * Benefits:
 * - Guaranteed valid JSON structure via generateObject()
 * - Built-in retry mechanisms and error handling
 * - Zod schema validation for type safety
 * - No manual JSON parsing or cleanup required
 *
 * Setup:
 * - Requires OPENAI_API_KEY environment variable
 * - Uses gpt-4o-mini for cost-effective structured generation
 *
 * Each sentence includes target language, user language, context, and audio generation
 */

import type { Lesson, Sentence } from '../../../shared/types/lesson'
import { Buffer } from 'node:buffer'
import { openai } from '@ai-sdk/openai'
import { valibotSchema } from '@ai-sdk/valibot'
import { generateObject } from 'ai'
import { desc, eq } from 'drizzle-orm'
import OpenAI from 'openai'
import { array, string, object as valibotObject } from 'valibot'
import { SYSTEM_PROMPTS, USER_PROMPTS } from './prompts'

export interface GenerateLessonsArgs {
  topics: string[]
  targetLanguage: string
  userLanguage: string
  userId: string
}

export interface GeneratedLessonResult {
  lesson: Lesson
  sentences: Sentence[]
}

interface ParsedSentence {
  targetText: string
  userText: string
  context: string
}

export async function generateLessons({
  topics,
  targetLanguage,
  userLanguage,
  userId,
}: GenerateLessonsArgs): Promise<GeneratedLessonResult> {
  try {
    // Step 1: Generate 5 simple sentences using AI with structured output
    const topicsString = topics.join(', ')

    const systemPrompt = SYSTEM_PROMPTS.generateSentences(targetLanguage)

    // Generate sentences using OpenAI via Vercel AI SDK
    const parsedSentences = await generateWithOpenAI(topicsString, targetLanguage, userLanguage, systemPrompt)

    if (!parsedSentences || parsedSentences.length === 0) {
      throw new Error('No valid sentences generated by AI')
    }

    // Step 2: Save lesson to database
    const db = useDrizzle()

    // Get next lesson number for this user
    const lastLesson = await db.select({ lessonNumber: tables.lessons.lessonNumber })
      .from(tables.lessons)
      .where(eq(tables.lessons.userId, userId))
      .orderBy(desc(tables.lessons.lessonNumber))
      .limit(1)
      .get()

    const nextLessonNumber = (lastLesson?.lessonNumber || 0) + 1

    // Create lesson
    const firstTopic = topics[0] || 'General'
    const capitalizedTopic = firstTopic.charAt(0).toUpperCase() + firstTopic.slice(1)
    const lessonTitle = `${capitalizedTopic} - Lesson ${nextLessonNumber}`

    const [newLesson] = await db.insert(tables.lessons).values({
      userId,
      title: lessonTitle,
      targetLanguage: targetLanguage.toLowerCase(),
      userLanguage: userLanguage.toLowerCase(),
      difficulty: 'intermediate',
      topics: JSON.stringify(topics),
      lessonNumber: nextLessonNumber,
      totalSentences: parsedSentences.length,
    }).returning()

    if (!newLesson) {
      throw new Error('Failed to create lesson')
    }

    // Step 3: Save sentences to database
    const sentencePromises = parsedSentences.map(async (sentenceData: ParsedSentence, index: number) => {
      const [sentence] = await db.insert(tables.sentences).values({
        lessonId: newLesson.id,
        userId,
        targetText: sentenceData.targetText,
        userText: sentenceData.userText,
        sentenceOrder: index + 1,
        context: sentenceData.context,
        difficulty: 'intermediate',
        audioGenerated: false,
      }).returning()

      return sentence
    })

    const sentences = await Promise.all(sentencePromises)

    // Step 4: Generate audio for sentences (async - don't wait)
    generateAudioForSentences(sentences, targetLanguage).catch((error) => {
      consola.error('Failed to generate audio for sentences:', error)
    })

    // Parse lesson data for return
    const lessonData: Lesson = {
      ...newLesson,
      topics: JSON.parse(newLesson.topics || '[]'),
      createdAt: new Date(newLesson.createdAt),
      updatedAt: new Date(newLesson.updatedAt),
    }

    const sentenceData: Sentence[] = sentences.map((sentence: any) => ({
      ...sentence,
      audioUrl: sentence.audioUrl || undefined,
      context: sentence.context || undefined,
      difficulty: sentence.difficulty || undefined,
      tags: sentence.tags ? JSON.parse(sentence.tags) : undefined,
      createdAt: new Date(sentence.createdAt),
      updatedAt: new Date(sentence.updatedAt),
    }))

    return {
      lesson: lessonData,
      sentences: sentenceData,
    }
  }
  catch (error) {
    consola.error('Error generating lessons:', error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to generate lessons: ${error instanceof Error ? error.message : String(error)}`,
    })
  }
}

/**
 * Generate structured sentences using Vercel AI SDK with OpenAI and Valibot
 */
async function generateWithOpenAI(
  topicsString: string,
  targetLanguage: string,
  userLanguage: string,
  systemPrompt: string,
): Promise<ParsedSentence[]> {
  // Define the Valibot schema for sentence generation
  const sentenceSchema = valibotObject({
    targetText: string(`Simple sentence in ${targetLanguage}`),
    userText: string(`Translation in ${userLanguage}`),
    context: string('Brief usage context for the sentence'),
  })

  const sentencesSchema = valibotObject({
    sentences: array(sentenceSchema, 'Exactly 5 simple sentences for language learning'),
  })

  // Generate structured object using AI SDK with OpenAI and Valibot
  const { object } = await generateObject({
    model: openai('gpt-4o-mini'), // Cost-effective model for structured generation
    schema: valibotSchema(sentencesSchema), // Convert Valibot schema to AI SDK format
    schemaName: 'language_sentences',
    schemaDescription: 'Language learning sentences with translations and context',
    system: systemPrompt,
    prompt: USER_PROMPTS.generateSentences(topicsString, targetLanguage, userLanguage),
    maxTokens: 2048,
    temperature: 0.3,
    maxRetries: 2,
  })

  consola.success(`Successfully generated ${object.sentences.length} sentences using OpenAI generateObject with Valibot`)
  return object.sentences
}

/**
 * Generate audio for sentences using OpenAI's official SDK with latest TTS model
 * This runs asynchronously and updates the database when complete
 */
async function generateAudioForSentences(
  sentences: any[],
  targetLanguage: string,
): Promise<void> {
  consola.warn(`Starting audio generation for ${sentences.length} sentences in ${targetLanguage}`)

  const db = useDrizzle()
  const config = useRuntimeConfig()

  if (!config.openaiApiKey) {
    consola.error('OpenAI API key not configured')
    throw new Error('OpenAI API key is required for audio generation')
  }

  // Initialize OpenAI client
  const openaiClient = new OpenAI({
    apiKey: config.openaiApiKey,
  })

  // Map language codes to OpenAI TTS voices
  const getVoiceForLanguage = (language: string): 'alloy' | 'echo' | 'fable' | 'onyx' | 'nova' | 'shimmer' => {
    const langLower = language.toLowerCase()
    switch (langLower) {
      case 'spanish':
      case 'es':
        return 'nova' // Good for Spanish
      case 'french':
      case 'fr':
        return 'shimmer' // Good for French
      case 'german':
      case 'de':
        return 'echo' // Good for German
      case 'italian':
      case 'it':
        return 'fable' // Good for Italian
      case 'portuguese':
      case 'pt':
        return 'onyx' // Good for Portuguese
      case 'english':
      case 'en':
      default:
        return 'alloy' // Default English voice
    }
  }

  const voice = getVoiceForLanguage(targetLanguage)

  for (const sentence of sentences) {
    try {
      consola.warn(`Generating audio for sentence ${sentence.id}: "${sentence.targetText}"`)

      // Generate audio using OpenAI's official SDK with latest TTS model
      const mp3 = await openaiClient.audio.speech.create({
        model: 'tts-1-hd', // Latest high-definition TTS model
        voice,
        input: sentence.targetText,
        response_format: 'mp3',
        speed: 1.0,
      })

      // Get the audio buffer
      const audioBuffer = Buffer.from(await mp3.arrayBuffer())
      const audioKey = `audio/sentences/${sentence.id}.mp3`

      // Store the audio in blob storage using hubBlob()
      await hubBlob().put(audioKey, audioBuffer, {
        httpMetadata: {
          contentType: 'audio/mpeg',
        },
      })

      // Update the sentence record with audio URL and mark as generated
      await db.update(tables.sentences)
        .set({
          audioUrl: `/api/audio/${audioKey}`,
          audioGenerated: true,
          updatedAt: sql`(unixepoch())`,
        })
        .where(eq(tables.sentences.id, sentence.id))

      consola.success(`✅ Audio generated successfully for sentence ${sentence.id} using OpenAI TTS-1-HD`)

      // Add a small delay to respect rate limits
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    catch (error) {
      consola.error(`❌ Failed to generate audio for sentence ${sentence.id}:`, error)

      // Mark as failed but don't throw - continue with other sentences
      try {
        await db.update(tables.sentences)
          .set({
            audioGenerated: false,
            updatedAt: sql`(unixepoch())`,
          })
          .where(eq(tables.sentences.id, sentence.id))
      }
      catch (dbError) {
        consola.error(`Failed to update sentence ${sentence.id} after audio generation error:`, dbError)
      }
    }
  }

  consola.success(`Completed audio generation for ${sentences.length} sentences using OpenAI TTS-1-HD`)
}
