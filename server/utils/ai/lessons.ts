/**
 * Generate Spanish learning sentences with audio using AI
 */
import type { Lesson, Sentence } from '../../../shared/types/lesson'
import { Buffer } from 'node:buffer'
import process from 'node:process'
import { openai } from '@ai-sdk/openai'
import { valibotSchema } from '@ai-sdk/valibot'
import { generateObject } from 'ai'
import { and, eq, sql } from 'drizzle-orm'
import OpenAI from 'openai'
import { array, string, object as valibotObject } from 'valibot'
import { type CourseLesson, fetchCourseContent } from '../../data/course-content'
import { generateRecapLesson, isRecapLesson } from '../recap'

export interface GenerateLessonsArgs {
  topics: string[]
  userId: string
  lessonNumber?: number
}

export interface GeneratedLessonResult {
  lesson: Lesson
  sentences: Sentence[]
}

interface ParsedSentence {
  targetText: string
  userText: string
  context: string
}

/**
 * Determine the number of sentences to generate based on difficulty level and score
 */
function getSentenceCountForDifficulty(difficultyLevel: string, difficultyScore: number): number {
  let base: number
  let maxSentences: number

  // Set base and max sentences based on difficulty level
  switch (difficultyLevel) {
    case 'A1':
      base = 8
      maxSentences = 12
      break
    case 'A2':
      base = 12
      maxSentences = 18
      break
    default:
      // B1, B2, C1, C2, etc.
      base = 18
      maxSentences = 25
      break
  }

  // Scale linearly within the band based on difficulty_score (1-10)
  const sentenceCount = base + Math.round((difficultyScore - 1) / 9 * (maxSentences - base))

  return sentenceCount
}

export async function generateLessons({
  topics,
  userId,
  lessonNumber,
}: GenerateLessonsArgs): Promise<GeneratedLessonResult> {
  try {
    // Check if this is a recap lesson
    if (lessonNumber && isRecapLesson(lessonNumber)) {
      consola.info(`Generating recap lesson ${lessonNumber}`)

      // Get course content for this lesson to get the title structure
      const courseContent = await fetchCourseContent()
      const courseLesson = courseContent.find(lesson => lesson.lesson_number === lessonNumber)
      if (!courseLesson) {
        throw new Error(`No course content found for lesson ${lessonNumber}`)
      }

      const db = useDrizzle()

      // Create a recap lesson record
      const recapTitle = `Recap: Lessons ${lessonNumber - 6} to ${lessonNumber - 1}`

      const [newLesson] = await db.insert(tables.lessons).values({
        userId,
        title: recapTitle,
        targetLanguage: 'spanish',
        userLanguage: 'english',
        difficulty: 'intermediate',
        topics: JSON.stringify(topics),
        lessonNumber,
        totalSentences: 0, // Recap lessons don't have sentences
        isRecapLesson: true,
        recapGenerated: false,
      }).returning()

      if (!newLesson) {
        throw new Error('Failed to create recap lesson')
      }

      // Generate the recap markdown content
      const { markdownUrl: _markdownUrl, content: _content } = await generateRecapLesson(userId, lessonNumber)

      // Parse lesson data for return
      const lessonData: Lesson = {
        ...newLesson,
        topics: JSON.parse(newLesson.topics || '[]'),
        comicImageUrl: newLesson.comicImageUrl || undefined,
        recapMarkdownUrl: newLesson.recapMarkdownUrl || undefined,
        createdAt: new Date(newLesson.createdAt),
        updatedAt: new Date(newLesson.updatedAt),
      }

      return {
        lesson: lessonData,
        sentences: [], // Recap lessons don't have sentences
      }
    }

    // Regular lesson generation continues here...
    // Get the course content for this lesson
    const courseContent = await fetchCourseContent()
    const courseLesson = courseContent.find(lesson => lesson.lesson_number === lessonNumber)
    if (!courseLesson) {
      throw new Error(`No course content found for lesson ${lessonNumber}`)
    }

    // Combine topics with course content
    const allTopics = [
      ...topics,
      ...courseLesson.vocabulary_topics,
      ...courseLesson.grammar_points,
      ...courseLesson.communication_goals,
    ]

    // Generate Spanish sentences using AI (count based on difficulty level)
    const topicsString = allTopics.join(', ')
    consola.info(`Generating sentences for lesson ${lessonNumber} with topics: ${topicsString}`)

    const parsedSentences = await generateSpanishSentences(topicsString, courseLesson)

    if (!parsedSentences || parsedSentences.length === 0) {
      consola.error(`Failed to generate sentences for lesson ${lessonNumber}. Course lesson:`, courseLesson)
      consola.error('Topics:', allTopics)
      throw new Error('No valid sentences generated by AI')
    }

    consola.success(`Generated ${parsedSentences.length} sentences for lesson ${lessonNumber}`)

    // Save lesson to database
    const db = useDrizzle()

    // Generate a fun, engaging title for this lesson
    const lessonTitle = await generateLessonTitle(courseLesson, parsedSentences)

    const [newLesson] = await db.insert(tables.lessons).values({
      userId,
      title: lessonTitle,
      targetLanguage: 'spanish',
      userLanguage: 'english',
      difficulty: 'intermediate',
      topics: JSON.stringify(allTopics),
      lessonNumber: courseLesson.lesson_number,
      totalSentences: parsedSentences.length,
    }).returning()

    if (!newLesson) {
      throw new Error('Failed to create lesson')
    }

    // Save sentences to database
    const sentencePromises = parsedSentences.map(async (sentenceData: ParsedSentence, index: number) => {
      const [sentence] = await db.insert(tables.sentences).values({
        lessonId: newLesson.id,
        userId,
        targetText: sentenceData.targetText,
        userText: sentenceData.userText,
        sentenceOrder: index + 1,
        context: sentenceData.context,
        difficulty: 'intermediate',
        audioGenerated: false,
      }).returning()

      return sentence
    })

    const sentences = await Promise.all(sentencePromises)

    // Generate audio for sentences and comic image for lesson (sync - wait for completion)
    await generateAudioAndComicImage(newLesson, sentences)

    // Fetch updated sentences with audio URLs after generation
    const updatedSentences = await db.select()
      .from(tables.sentences)
      .where(eq(tables.sentences.lessonId, newLesson.id))
      .orderBy(tables.sentences.sentenceOrder)
      .all()

    // Parse lesson data for return
    const lessonData: Lesson = {
      ...newLesson,
      topics: JSON.parse(newLesson.topics || '[]'),
      comicImageUrl: newLesson.comicImageUrl || undefined,
      recapMarkdownUrl: newLesson.recapMarkdownUrl || undefined,
      createdAt: new Date(newLesson.createdAt),
      updatedAt: new Date(newLesson.updatedAt),
    }

    const sentenceData: Sentence[] = updatedSentences.map((sentence: any) => ({
      ...sentence,
      audioUrl: sentence.audioUrl || undefined,
      context: sentence.context || undefined,
      difficulty: sentence.difficulty || undefined,
      tags: sentence.tags ? JSON.parse(sentence.tags) : undefined,
      createdAt: new Date(sentence.createdAt),
      updatedAt: new Date(sentence.updatedAt),
    }))

    return {
      lesson: lessonData,
      sentences: sentenceData,
    }
  }
  catch (error) {
    consola.error('Error generating lessons:', error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to generate lessons: ${error instanceof Error ? error.message : String(error)}`,
    })
  }
}

/**
 * Generate a funny, engaging lesson title based on the lesson content and conversation level
 */
async function generateLessonTitle(courseLesson: CourseLesson, sentences: ParsedSentence[]): Promise<string> {
  try {
    const titleSchema = valibotObject({
      title: string('A funny, engaging one-sentence title that summarizes what the lesson is about'),
    })

    // Extract the conversation content for context
    const conversationContent = sentences.map(s => s.targetText).join(' ')
    const conversationTranslation = sentences.map(s => s.userText).join(' ')

    const { object } = await generateObject({
      model: openai('gpt-4o-mini'),
      schema: valibotSchema(titleSchema),
      schemaName: 'lesson_title',
      schemaDescription: 'A funny, engaging lesson title that matches the conversation level',
      system: `You are a creative copywriter specializing in language learning content. Create a funny, engaging title for a Spanish lesson that:

1. Is ONE SENTENCE that summarizes what the lesson is about
2. Matches the conversation level (${courseLesson.difficulty_level} - ${courseLesson.difficulty_score}/10)
3. Is relatable and slightly humorous 
4. Captures the essence of what students will learn to communicate about
5. Sounds natural and engaging, not overly academic

LEVEL GUIDELINES:
- A1 (scores 1-2): Simple, everyday situations with basic language
- A1 (scores 3-5): More complex everyday situations but still fundamental
- A2 (scores 3-6): Broader topics with more nuanced communication
- B1 (scores 7-10): Complex conversations and sophisticated topics

EXAMPLES OF GOOD TITLES:
- "When your GPS fails you and you actually need to ask for directions like a normal person"
- "How to complain about your hotel room without sounding like a total tourist"
- "Navigating family dinner conversations when everyone has opinions about your life choices"
- "The art of ordering food when you can't pronounce half the menu"
- "When small talk at work gets unexpectedly deep and philosophical"

Make it conversational, relatable, and something that would make someone smile while learning.`,
      prompt: `Create a title for this Spanish lesson:

Level: ${courseLesson.difficulty_level} (difficulty ${courseLesson.difficulty_score}/10)
Grammar focus: ${courseLesson.grammar_points.join(', ')}
Topics: ${courseLesson.vocabulary_topics.join(', ')}
Communication goals: ${courseLesson.communication_goals.join(', ')}

The conversation in this lesson covers:
Spanish: ${conversationContent}
English: ${conversationTranslation}

Generate a funny, engaging one-sentence title that captures what this lesson is really about.`,
      maxTokens: 200,
      temperature: 0.7,
      maxRetries: 2,
    })

    consola.success(`Generated lesson title: "${object.title}"`)
    return object.title
  }
  catch (error) {
    consola.error('Error generating lesson title:', error)
    // Fallback to a generic title if generation fails
    const topicSummary = courseLesson.vocabulary_topics.slice(0, 2).join(' and ')
    return `Lesson ${courseLesson.lesson_number}: Learning to talk about ${topicSummary}`
  }
}

/**
 * Generate Spanish sentences using OpenAI
 */
async function generateSpanishSentences(topicsString: string, courseLesson: CourseLesson): Promise<ParsedSentence[]> {
  try {
    consola.info(`Starting Spanish sentence generation for lesson ${courseLesson.lesson_number}`)

    // Determine sentence count based on difficulty level
    const sentenceCount = getSentenceCountForDifficulty(courseLesson.difficulty_level, courseLesson.difficulty_score)
    consola.info(`Generating ${sentenceCount} sentences for difficulty level ${courseLesson.difficulty_level}`)

    const sentenceSchema = valibotObject({
      targetText: string('Natural Spanish sentence as it would be spoken by native speakers'),
      userText: string('Natural English translation that captures the meaning and tone'),
      context: string('Assimil-style explanatory note with cultural and linguistic insights'),
    })

    const sentencesSchema = valibotObject({
      sentences: array(sentenceSchema, `Exactly ${sentenceCount} conversational Spanish sentences following Assimil methodology`),
    })

    // Generate structured object using AI SDK
    const { object } = await generateObject({
      model: openai('gpt-4o-mini'),
      schema: valibotSchema(sentencesSchema),
      schemaName: 'assimil_spanish_sentences',
      schemaDescription: 'Spanish sentences with its translation and with Assimil-style contextual notes for natural language acquisition',
      system: `You are an expert Spanish language instructor following the ASSIMIL METHOD for natural language acquisition. Generate exactly ${sentenceCount} Spanish sentences that form a natural conversation.

ASSIMIL METHOD PRINCIPLES:
- Present language as it's naturally spoken by native speakers
- Focus on intuitive understanding rather than explicit grammar rules
- Provide rich cultural and linguistic context
- Use authentic, everyday situations and expressions
- Progress naturally from comprehension to expression

SENTENCE REQUIREMENTS:
- Use vocabulary related to: ${topicsString}
- Grammar focus: ${courseLesson.grammar_points.join(', ')}
- Communication goals: ${courseLesson.communication_goals.join(', ')}
- Vocabulary themes: ${courseLesson.vocabulary_topics.join(', ')}
- Target level: ${courseLesson.difficulty_level} (score ${courseLesson.difficulty_score}/10)
- Create a natural dialogue between 2 people (alternating speakers)
- Each sentence flows naturally from the previous one
- Use authentic expressions and natural speech patterns
- Length: 8-15 words per sentence (natural conversational length)

CONTEXT NOTES (Assimil-style):
For each sentence, provide explanatory notes that include:
- Cultural insights about when/where this expression is used
- Linguistic patterns or interesting grammar points (explained intuitively)
- Alternative ways to express the same idea
- Register notes (formal/informal, regional variations)
- Practical usage tips for real conversations
- Word-by-word breakdown only when it adds insight
- Connections to similar expressions in English when helpful

EXAMPLES OF ASSIMIL-STYLE CONTEXT:
Bad: "This sentence uses the present tense."
Good: "This is how Spanish speakers naturally greet a friend they haven't seen in a while. Notice the warmth conveyed by 'qué tal' - it's more personal than just 'hola'. In Latin America, you might hear 'qué hubo' instead."

Bad: "Subjunctive mood is used here."
Good: "Spanish speakers use this construction when they're not entirely sure about something. It's softer and more polite than stating it as a fact. You'll hear this pattern a lot in everyday conversation when people are being courteous."`,
      prompt: `Create a natural Spanish conversation about: ${topicsString}
    
Target level: ${courseLesson.difficulty_level} (difficulty ${courseLesson.difficulty_score}/10)

Generate ${sentenceCount} sentences that tell a story or present a realistic scenario. Each sentence should feel authentic and include rich Assimil-style context that helps learners understand not just WHAT is being said, but HOW, WHEN, and WHY Spanish speakers use these expressions.`,
      maxTokens: 3000,
      temperature: 0.4,
      maxRetries: 2,
    })

    consola.success(`Successfully generated ${object.sentences.length} Spanish sentences`)
    return object.sentences
  }
  catch (error) {
    consola.error(`Failed to generate Spanish sentences for lesson ${courseLesson.lesson_number}:`, error)
    throw error
  }
}

/**
 * Retry wrapper for blob storage operations with exponential backoff
 */
async function retryBlobOperation<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000,
): Promise<T> {
  let lastError: Error = new Error('Operation failed after all retries')

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation()
    }
    catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error))

      // Check if this is a retryable Cloudflare error
      const isRetryableError = error && typeof error === 'object'
        && 'message' in error
        && (
          (error.message as string).includes('10043') // Service unavailable
          || (error.message as string).includes('10000') // Generic server error
          || (error.message as string).includes('timeout')
          || (error.message as string).includes('network')
        )

      if (!isRetryableError || attempt === maxRetries) {
        throw lastError
      }

      // Exponential backoff with jitter
      const delay = baseDelay * 2 ** (attempt - 1) + Math.random() * 1000
      consola.warn(`Blob operation failed (attempt ${attempt}/${maxRetries}), retrying in ${Math.round(delay)}ms: ${lastError.message}`)
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }

  throw lastError
}

/**
 * Generate audio for Spanish sentences and comic image for lesson using OpenAI
 */
async function generateAudioAndComicImage(lesson: any, sentences: any[]): Promise<void> {
  consola.warn(`Starting audio and comic image generation for lesson ${lesson.id} with ${sentences.length} sentences`)

  const db = useDrizzle()
  const config = useRuntimeConfig()

  if (!config.openaiApiKey) {
    consola.error('OpenAI API key not configured')
    throw new Error('OpenAI API key is required for audio and comic image generation')
  }

  // Initialize OpenAI client
  const openaiClient = new OpenAI({
    apiKey: config.openaiApiKey,
  })

  // Generate audio for all sentences first
  for (const sentence of sentences) {
    try {
      consola.warn(`Generating Spanish audio for sentence ${sentence.id}: "${sentence.targetText}"`)

      // Generate audio using OpenAI TTS with Spanish voice
      const mp3 = await openaiClient.audio.speech.create({
        model: 'gpt-4o-mini-tts',
        voice: 'nova', // Good Spanish voice
        input: sentence.targetText,
        response_format: 'mp3',
        speed: 1.0,
        instructions: 'Speak in a cheerful and positive tone in spanish from Costa Rica.',
      })

      consola.info(`✅ OpenAI TTS generation completed for sentence ${sentence.id}`)

      // Get the audio buffer
      const audioBuffer = Buffer.from(await mp3.arrayBuffer())
      const audioKey = `audio/users/${sentence.userId}/sentences/${sentence.id}.mp3`

      // Store the audio in blob storage with retry logic
      try {
        await retryBlobOperation(async () => {
          // Convert Buffer to Blob for NuxtHub compatibility
          const audioBlob = new Blob([audioBuffer], { type: 'audio/mpeg' })
          await hubBlob().put(audioKey, audioBlob, {
            httpMetadata: {
              contentType: 'audio/mpeg',
            },
          })
          consola.success(`✅ Audio stored successfully: ${audioKey}`)
        }, 3, 2000) // 3 retries with 2s base delay
      }
      catch (blobError) {
        const errorMessage = blobError instanceof Error ? blobError.message : String(blobError)
        const isCloudflareServiceIssue = errorMessage.includes('10043')
          || errorMessage.includes('cloudflarestatus.com')
          || errorMessage.includes('contact customer support')

        if (isCloudflareServiceIssue) {
          consola.error(`❌ Cloudflare service issue detected for ${audioKey}. Marking sentence for later retry.`)
          try {
            await db.update(tables.sentences)
              .set({
                audioGenerated: false,
                audioUrl: null,
                updatedAt: sql`(unixepoch())`,
              })
              .where(eq(tables.sentences.id, sentence.id))
            consola.warn(`⚠️ Sentence ${sentence.id} marked for audio retry due to service issue`)
            continue
          }
          catch (dbError) {
            consola.error(`Failed to update sentence ${sentence.id} after service issue:`, dbError)
          }
        }
        else {
          consola.error(`❌ Blob storage failed for ${audioKey}:`, blobError)
          throw blobError
        }
      }

      // Update the sentence record with audio URL
      await db.update(tables.sentences)
        .set({
          audioUrl: `/api/audio/${audioKey}`,
          audioGenerated: true,
          updatedAt: sql`(unixepoch())`,
        })
        .where(eq(tables.sentences.id, sentence.id))

      consola.success(`✅ Spanish audio generated for sentence ${sentence.id}`)

      // Small delay to respect rate limits
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    catch (error) {
      const isDevEnvironment = process.env.NODE_ENV === 'development'
      const isBlobError = error && typeof error === 'object' && 'message' in error
        && (error.message as string).includes('ArrayBufferView')

      if (isDevEnvironment && isBlobError) {
        consola.warn(`⚠️ Audio generation skipped in development for sentence ${sentence.id} (blob storage issue)`)
        try {
          await db.update(tables.sentences)
            .set({
              audioGenerated: true,
              audioUrl: null,
              updatedAt: sql`(unixepoch())`,
            })
            .where(eq(tables.sentences.id, sentence.id))
        }
        catch (dbError) {
          consola.error(`Failed to update sentence ${sentence.id} after dev audio skip:`, dbError)
        }
      }
      else {
        consola.error(`❌ Failed to generate audio for sentence ${sentence.id}:`, error)
        try {
          await db.update(tables.sentences)
            .set({
              audioGenerated: false,
              updatedAt: sql`(unixepoch())`,
            })
            .where(eq(tables.sentences.id, sentence.id))
        }
        catch (dbError) {
          consola.error(`Failed to update sentence ${sentence.id} after audio error:`, dbError)
        }
      }
    }
  }

  // Now generate comic image for the lesson
  try {
    consola.warn(`Generating comic image for lesson ${lesson.id}: "${lesson.title}"`)

    // Extract key Spanish words from the lesson
    const spanishWords = sentences.map(s => s.targetText)
    const randomWords = spanishWords.slice(0, 3) // Use first 3 words for the scene

    // Create prompt for comic image focusing on funny situations
    const comicPrompt = `Create a funny black and white line art illustration showing a humorous everyday situation where someone might use these Spanish words: ${randomWords.join(', ')}.

IMPORTANT: Don't make it a "Spanish lesson" image. Instead, create a funny, relatable scenario where these words would naturally come up in conversation.

For example:
- If the words are about food, show someone in a funny restaurant situation
- If about travel, show a comical travel mishap  
- If about family, show a silly family gathering
- If about shopping, show an amusing shopping experience

The image should:
- Be in a clean black and white line art style with NO COLORS
- Use only black lines on white background, like a comic book coloring page
- Show characters in a funny, everyday situation where these Spanish words would be used
- Include 2-3 Spanish words as speech bubbles or text elements naturally within the scene
- Be humorous and memorable, helping students remember the words through the funny context
- Have clear, bold line work that's easy to see and understand
- Focus on the comedy of the situation rather than being "educational"

Style: Black and white line art comic illustration with clean, bold outlines and clear, readable Spanish text in speech bubbles. NO COLORS - only black lines on white background.`

    consola.info(`Comic image prompt: ${comicPrompt.substring(0, 200)}...`)

    // Generate image using DALL-E 3
    const response = await openaiClient.images.generate({
      model: 'dall-e-3',
      prompt: comicPrompt,
      n: 1,
      size: '1024x1024',
      quality: 'standard',
      response_format: 'url',
    })

    const imageUrl = response.data?.[0]?.url
    if (!imageUrl) {
      throw new Error('No image URL returned from DALL-E')
    }

    consola.info(`✅ DALL-E image generation completed for lesson ${lesson.id}`)

    // Download the image
    const imageResponse = await fetch(imageUrl)
    if (!imageResponse.ok) {
      throw new Error(`Failed to download image: ${imageResponse.statusText}`)
    }

    const imageBuffer = Buffer.from(await imageResponse.arrayBuffer())
    const imageKey = `images/users/${lesson.userId}/lessons/${lesson.id}.png`

    // Store the image in blob storage
    try {
      await retryBlobOperation(async () => {
        const imageBlob = new Blob([imageBuffer], { type: 'image/png' })
        await hubBlob().put(imageKey, imageBlob, {
          httpMetadata: {
            contentType: 'image/png',
          },
        })
        consola.success(`✅ Comic image stored successfully: ${imageKey}`)
      }, 3, 2000)
    }
    catch (blobError) {
      consola.error(`❌ Failed to store comic image: ${blobError}`)
      // Mark as failed but don't throw - lesson should still work without image
      await db.update(tables.lessons)
        .set({
          comicImageGenerated: false,
          updatedAt: sql`(unixepoch())`,
        })
        .where(eq(tables.lessons.id, lesson.id))
      return
    }

    // Update the lesson record with comic image URL
    await db.update(tables.lessons)
      .set({
        comicImageUrl: `/api/images/${imageKey}`,
        comicImageGenerated: true,
        updatedAt: sql`(unixepoch())`,
      })
      .where(eq(tables.lessons.id, lesson.id))

    consola.success(`✅ Comic image generated for lesson ${lesson.id}`)
  }
  catch (error) {
    consola.error(`❌ Failed to generate comic image for lesson ${lesson.id}:`, error)
    // Mark as failed but don't throw - lesson should still work without image
    try {
      await db.update(tables.lessons)
        .set({
          comicImageGenerated: false,
          updatedAt: sql`(unixepoch())`,
        })
        .where(eq(tables.lessons.id, lesson.id))
    }
    catch (dbError) {
      consola.error(`Failed to update lesson after comic image error:`, dbError)
    }
  }

  consola.success(`Completed audio and comic image generation for lesson ${lesson.id}`)
}

/**
 * Retry comic image generation for lessons that failed due to service issues
 */
export async function retryFailedComicImageGeneration(lessonId?: string | number): Promise<void> {
  const db = useDrizzle()

  // Find lessons without comic images
  let failedLessons

  if (lessonId) {
    const lessonIdNum = typeof lessonId === 'string' ? Number.parseInt(lessonId, 10) : lessonId
    failedLessons = await db.select()
      .from(tables.lessons)
      .where(
        and(
          eq(tables.lessons.comicImageGenerated, false),
          eq(tables.lessons.id, lessonIdNum),
        ),
      )
      .all()
  }
  else {
    failedLessons = await db.select()
      .from(tables.lessons)
      .where(eq(tables.lessons.comicImageGenerated, false))
      .all()
  }

  if (failedLessons.length === 0) {
    consola.info('No lessons found that need comic image generation retry')
    return
  }

  consola.info(`Found ${failedLessons.length} lessons that need comic image generation retry`)

  // Generate comic images for failed lessons
  for (const lesson of failedLessons) {
    // Get sentences for this lesson
    const sentences = await db.select()
      .from(tables.sentences)
      .where(eq(tables.sentences.lessonId, lesson.id))
      .orderBy(tables.sentences.sentenceOrder)
      .all()

    await generateAudioAndComicImage(lesson, sentences)
  }
}

/**
 * Retry audio generation for sentences that failed due to service issues
 */
export async function retryFailedAudioGeneration(lessonId?: string | number): Promise<void> {
  const db = useDrizzle()

  // Find sentences without audio
  let failedSentences

  if (lessonId) {
    const lessonIdNum = typeof lessonId === 'string' ? Number.parseInt(lessonId, 10) : lessonId
    failedSentences = await db.select()
      .from(tables.sentences)
      .where(
        and(
          eq(tables.sentences.audioGenerated, false),
          eq(tables.sentences.lessonId, lessonIdNum),
        ),
      )
      .all()
  }
  else {
    failedSentences = await db.select()
      .from(tables.sentences)
      .where(eq(tables.sentences.audioGenerated, false))
      .all()
  }

  if (failedSentences.length === 0) {
    consola.info('No sentences found that need audio generation retry')
    return
  }

  consola.info(`Found ${failedSentences.length} sentences that need audio generation retry`)

  // Use the existing audio generation logic - for now just handle audio retry separately
  // TODO: Consider if we want to regenerate comic images for audio retries
  consola.info('Audio retry not yet implemented with new combined function')
}
